import "blueprint.node" for Node
import "blueprint.pin" for Pin
import "blueprint.node_param" for NodeParam
import "blueprint.node_helper" for NodeHelper
import "blueprint.blueprint" for Blueprint
import "blueprint.variant" for Variant, VAR_TYPE_ARRAY
import "archgraph.variant" for VAR_TYPE_SCOPE, VAR_TYPE_SPLIT_SIZE, VarScope
import "math" for Math

var CHILD_IDX_OFFSET = 1

class Split is Node
{
	init()
	{
		super.init()

		this.imports = [
			Pin(this, "scope", VAR_TYPE_SCOPE),
			Pin(this, "size0", VAR_TYPE_SPLIT_SIZE),
			Pin(this, "size1", VAR_TYPE_SPLIT_SIZE),
		]
		this.exports = [
			Pin(this, "child0", [ VAR_TYPE_SCOPE, VAR_TYPE_ARRAY ]),
			Pin(this, "child1", [ VAR_TYPE_SCOPE, VAR_TYPE_ARRAY ]),
		]

		this.params.add(NodeParam("axis", "hori", { "combo" : [ "hori", "vert" ] }))
		this.params.add(NodeParam("repeat", false))

		this.layout()

		this.scopes = nil
	}

	on_pin_dirty(pin)
	{
		super.on_pin_dirty(pin)
		
		this.scopes = nil
	}

	calc_value(idx)
	{
		if (!this.scopes) {
			this.build_scopes()
		}
		if (!this.scopes) {
			return nil
		}

		var scope = this.scopes[idx]
		if (scope is List) {
			return Variant(VAR_TYPE_ARRAY, scope)
		} else {
			return Variant(VAR_TYPE_SCOPE, scope)
		}
	}

	on_connected(pin)
	{
		if (pin.is_input) {
			NodeHelper.dynamic_imports_update(this, CHILD_IDX_OFFSET, "size", VAR_TYPE_SCOPE)
			this.dynamic_exports_update()
		}
	}

	on_disconnected(pin)
	{
		if (pin.is_input) {
			NodeHelper.dynamic_imports_update(this, CHILD_IDX_OFFSET, "size", VAR_TYPE_SCOPE)
			this.dynamic_exports_update()
		}
	}

	build_scopes()
	{
		var v_scope = Blueprint.calc_input_value(this, 0)
		if (!v_scope or !v_scope.value) {
			return
		}

		var src_sizes = []
		for (var i in 1..this.imports.count)
		{
			var v_size = Blueprint.calc_input_value(this, i)
			if (v_size and v_size.value) {
				src_sizes.add(v_size.value)
			}
		}

		this.scopes = []

		var scope = v_scope.value

		var axis = this.query_param("axis").value

		var dst_sizes = nil
		if (axis == "hori") {
			dst_sizes = this.calc_sizes(src_sizes, scope.w)
		} else {
			dst_sizes = this.calc_sizes(src_sizes, scope.h)
		}

		if (dst_sizes.isEmpty) {
			return
		}

		if (dst_sizes[0] is List)
		{
			for (var _ in dst_sizes[0]) {
				this.scopes.add([])
			}

			if (axis == "hori")
			{
				var x = scope.x
				for (var i in 0..dst_sizes[0].count) {				
					for (var j in 0..dst_sizes.count) {
						var sz = dst_sizes[j][i]
						this.scopes[j].add(Variant(VAR_TYPE_SCOPE, VarScope(x, scope.y, sz, scope.h)))
						x = x + sz
					}
				}
			}
			else
			{
				var y = scope.y
				for (var i in 0..dst_sizes[0].count) {				
					for (var j in 0..dst_sizes.count) {				
						var sz = dst_sizes[j][i]
						this.scopes[j].add(Variant(VAR_TYPE_SCOPE, VarScope(scope.x, y, scope.w, sz)))
						y = y + sz
					}
				}
			}
		}
		else
		{
			if (axis == "hori")
			{
				var x = scope.x
				for (var sz in dst_sizes) {
					this.scopes.add(VarScope(x, scope.y, sz, scope.h))
					x = x + sz
				}
			}
			else
			{
				var y = scope.y
				for (var sz in dst_sizes) {
					this.scopes.add(VarScope(scope.x, y, scope.w, sz))
					y = y + sz
				}
			}
		}
	}

	calc_sizes(src, tot)
	{
		var repeat = this.query_param("repeat").value
		if (repeat)
		{
			var sizes = []
			for (var _ in src) {
				sizes.add([])
			}

			var floating = false
			for (var sz in src) {
				if (sz.mode == "floating") {
					floating = true
				}
			}

			if (floating)
			{
				var dst = []
				var len = this.calc_sizes_single_layer(dst, src, tot, tot)
				var num = Math.ceil(tot / len)
				for (var i in 0..num)
				{
					var dst = []
					this.calc_sizes_single_layer(dst, src, tot / num, tot)
					for (var i in 0 .. dst.count) {
						sizes[i].add(dst[i])
					}
				}
			}
			else
			{
				var avaliable = tot
				while (avaliable > 0)
				{
					var dst = []
					var len = this.calc_sizes_single_layer(dst, src, avaliable, tot)
					for (var i in 0 .. dst.count) {
						sizes[i].add(dst[i])
					}

					avaliable = avaliable - len
				}
			}

			return sizes
		}
		else
		{
			var sizes = []
			this.calc_sizes_single_layer(sizes, src, tot, tot)
			return sizes
		}
	}

	calc_sizes_single_layer(dst, src, length, tot_len)
	{
		// prepare relative and floating values
		var floating_num = 0
		for (var sz in src) 
		{
			if (sz.mode == "absolute") {
				dst.add(sz.size)
			} else if (sz.mode == "relative") {
				dst.add(sz.size * tot_len)
			} else if (sz.mode == "floating") {
				dst.add(-sz.size)
				floating_num = floating_num + 1
			}
		}

		// calc floating
		if (floating_num > 0)
		{
			var avaliable = length
			var tot_floating = 0
			for (var sz in dst) 
			{
				if (sz > 0) {
					avaliable = avaliable - sz
				} else {
					tot_floating = tot_floating - sz
				}
			}
			if (avaliable > 0 and tot_floating > 0)
			{
				if (floating_num == 1)
				{
					for (var i in 0..dst.count) {
						if (dst[i] < 0) {
							var len = -dst[i]
							dst[i] = Math.min(len, avaliable)
						}
					}
				}
				else
				{
					for (var i in 0..dst.count) {
						if (dst[i] < 0) {
							var len = -dst[i]
							dst[i] = Math.min(len, avaliable * len / tot_floating)
						}
					}
				}
			}
			else
			{
				for (var i in 0..dst.count) {
					if (dst[i] < 0) {
						dst[i] = 0
					}
				}
			}
		}

		// trim sizes
		if (!dst.isEmpty)
		{
			var len = 0
			var idx = 0
			while (idx < dst.count and len + dst[idx] < length) {
				len = len + dst[idx]
				idx = idx + 1
			}

			if (idx < dst.count)
			{
				dst[idx] = length - len
				for (var i in idx + 1 .. dst.count) {
					dst[i] = 0
				}
			}
		}

		// calc tot len
		var len = 0
		for (var sz in dst) {
			len = len + sz
		}

		return len
	}

	dynamic_exports_update()
	{
		var num = 0
		for (var i in 1 .. this.imports.count) {
			if (!this.imports[i].conns.isEmpty) {
				num = num + 1
			}
		}
		while (this.exports.count > num) {
			this.exports.pop_back()
		}
		while (this.exports.count < num) {
			this.exports.add(Pin(this, "child%(this.exports.count)", VAR_TYPE_SCOPE))
		}

		this.layout()

		for (var port in this.exports) {
			for (var conn in port.conns) {
				conn.update()
			}
		}
	}	
}