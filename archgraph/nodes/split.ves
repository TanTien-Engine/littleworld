import "blueprint.node" for Node
import "blueprint.pin" for Pin
import "blueprint.node_param" for NodeParam
import "blueprint.node_helper" for NodeHelper
import "blueprint.blueprint" for Blueprint
import "blueprint.variant" for Variant, VAR_TYPE_ARRAY
import "blueprint.variant_helper" for VariantHelper
import "archgraph.variant" for VAR_TYPE_GEOMETRY, VAR_TYPE_SPLIT_SIZE
import "archgraph.geometry" for Geometry
import "archgraph.scope_helper" for ScopeHelper
import "maths.vector" for Vector3
import "archgen" for ScopeTools
import "geometry" for PolyPoint, PolyFace, Polytope
import "math" for Math

var CHILD_IDX_OFFSET = 1

class SplitSize
{
	init(size, scale)
	{
		this.size  = size
		this.scale = scale
	}
}

class SplitRect
{
	init(x, y, w, h)
	{
		this.x = x
		this.y = y
		this.w = w
		this.h = h
		this.s = 1.0
	}
}

class Split is Node
{
	init()
	{
		super.init()

		this.imports = [
			Pin(this, "parent", VAR_TYPE_GEOMETRY),
			Pin(this, "size0",  VAR_TYPE_SPLIT_SIZE),
			Pin(this, "size1",  VAR_TYPE_SPLIT_SIZE),
		]
		this.exports = [
			Pin(this, "child0", [ VAR_TYPE_GEOMETRY, VAR_TYPE_ARRAY ]),
			Pin(this, "child1", [ VAR_TYPE_GEOMETRY, VAR_TYPE_ARRAY ]),
		]

		this.params.add(NodeParam("axis", "hori", { "combo" : [ "hori", "vert" ] }))
		this.params.add(NodeParam("repeat", false))

		this.layout()
	}

	calc_value(idx)
	{
		var children = this.build_children()
		if (!children) {
			return nil
		}

		var geos = children[idx]
		if (geos.count > 1) {
			return Variant(VAR_TYPE_ARRAY, geos)
		} else if (geos.count == 1) {
			return geos[0]
		} else {
			return nil
		}
	}

	on_connected(pin)
	{
		if (pin.is_input) {
			NodeHelper.dynamic_imports_update(this, CHILD_IDX_OFFSET, "size", VAR_TYPE_GEOMETRY)
			this.dynamic_exports_update()
		}
	}

	on_disconnected(pin)
	{
		if (pin.is_input) {
			NodeHelper.dynamic_imports_update(this, CHILD_IDX_OFFSET, "size", VAR_TYPE_GEOMETRY)
			this.dynamic_exports_update()
		}
	}

	build_children()
	{
		var children = []
		for (var i in 0 .. this.exports.count) {
			children.add([])
		}

		var v_geo = Blueprint.calc_input_value(this, 0)
		if (v_geo)
		{
			this.build_children(v_geo, children)
		}
		else
		{
			var rects = this.build_rects(1, 1)
			for (var i in 0 .. rects.count) {
				for (var r in rects[i]) {
					children[i].add(this.create_geo(r))
				}
			}
		}

		return children
	}	

	build_children(v_geo, children)
	{
		var in_geos = VariantHelper.flatten_values(v_geo, VAR_TYPE_GEOMETRY)
		for (var geo in in_geos) {
			for (var poly in geo.mesh.polys) {
				var points = poly.get_points()
				for (var face in poly.get_faces()) {
					var map = ScopeTools.face_mapping(poly, face)
					if (map)
					{
						var ori_p = Vector3(map[0], map[1], map[2])
						var dir_x = Vector3(map[3], map[4], map[5])
						var dir_y = Vector3(map[6], map[7], map[8])

						var width  = dir_x.length()
						var height = dir_y.length()
						var rects = this.build_rects(width, height)

						dir_x.normalize()
						dir_y.normalize()

						for (var i in 0 .. rects.count) {
							for (var r in rects[i]) {
								children[i].add(this.create_geo(r, face, points, ori_p, dir_x, dir_y, geo.scope))
							}
						}						
					}
				}
			}
		}
	}

	build_rects(width, height)
	{
		var src_sizes = []
		for (var i in 1..this.imports.count)
		{
			var v_size = Blueprint.calc_input_value(this, i)
			if (v_size and v_size.value) {
				src_sizes.add(v_size.value)
			}
		}

		var rects = []

		var axis = this.query_param("axis").value

		var dst_sizes = nil
		if (axis == "hori") {
			dst_sizes = this.calc_sizes(src_sizes, width)
		} else {
			dst_sizes = this.calc_sizes(src_sizes, height)
		}

		if (dst_sizes.isEmpty) {
			return
		}

		var rect = SplitRect(0, 0, width, height)

		for (var _ in dst_sizes) {
			rects.add([])
		}
		if (dst_sizes[0] is List)
		{
			if (axis == "hori")
			{
				var x = rect.x
				for (var i in 0..dst_sizes[0].count) {				
					for (var j in 0..dst_sizes.count) {
						var sz = dst_sizes[j][i]
						var sr = SplitRect(x, rect.y, sz.size, rect.h)
						sr.s = sz.scale
						rects[j].add(sr)
						x = x + sz.size
					}
				}
			}
			else
			{
				var y = rect.y
				for (var i in 0..dst_sizes[0].count) {				
					for (var j in 0..dst_sizes.count) {				
						var sz = dst_sizes[j][i]
						var sr = SplitRect(rect.x, y, rect.w, sz.size)
						sr.s = sz.scale
						rects[j].add(sr)
						y = y + sz.size
					}
				}
			}
		}
		else
		{
			if (axis == "hori")
			{
				var x = rect.x
				for (var i in 0 .. dst_sizes.count) 
				{
					var sz = dst_sizes[i]
					var sr = SplitRect(x, rect.y, sz.size, rect.h)
					sr.s = sz.scale
					rects[i].add(sr)
					x = x + sz.size
				}
			}
			else
			{
				var y = rect.y
				for (var i in 0 .. dst_sizes.count) 
				{
					var sz = dst_sizes[i]
					var sr = SplitRect(rect.x, y, rect.w, sz.size)
					sr.s = sz.scale
					rects[i].add(sr)
					y = y + sz.size
				}
			}
		}

		return rects
	}

	calc_sizes(src, tot)
	{
		var repeat = this.query_param("repeat").value
		if (repeat)
		{
			var sizes = []
			for (var _ in src) {
				sizes.add([])
			}

			var floating = false
			for (var sz in src) {
				if (sz.mode == "floating") {
					floating = true
				}
			}

			if (floating)
			{
				var dst = []
				var len = this.calc_sizes_single_layer(dst, src, tot, tot)
				var num = Math.ceil(tot / len)
				for (var i in 0..num)
				{
					var dst = []
					this.calc_sizes_single_layer(dst, src, tot / num, tot)
					for (var i in 0 .. dst.count) {
						sizes[i].add(dst[i])
					}
				}
			}
			else
			{
				var avaliable = tot
				while (avaliable > 0)
				{
					var dst = []
					var len = this.calc_sizes_single_layer(dst, src, avaliable, tot)
					for (var i in 0 .. dst.count) {
						sizes[i].add(dst[i])
					}

					avaliable = avaliable - len
				}
			}

			return sizes
		}
		else
		{
			var sizes = []
			this.calc_sizes_single_layer(sizes, src, tot, tot)
			return sizes
		}
	}

	calc_sizes_single_layer(dst, src, length, tot_len)
	{
		// prepare relative and floating values
		var floating_num = 0
		for (var sz in src) 
		{
			if (sz.mode == "absolute") {
				dst.add(SplitSize(sz.size, sz.scale))
			} else if (sz.mode == "relative") {
				dst.add(SplitSize(sz.size * tot_len, sz.scale))
			} else if (sz.mode == "floating") {
				dst.add(SplitSize(-sz.size, sz.scale))
				floating_num = floating_num + 1
			}
		}

		// calc floating
		if (floating_num > 0)
		{
			var avaliable = length
			var tot_floating = 0
			for (var sz in dst) 
			{
				if (sz.size > 0) {
					avaliable = avaliable - sz.size
				} else {
					tot_floating = tot_floating - sz.size
				}
			}
			if (avaliable > 0 and tot_floating > 0)
			{
				if (floating_num == 1)
				{
					for (var i in 0..dst.count) {
						if (dst[i].size < 0) {
							var len = -dst[i].size
							dst[i].size = Math.min(len, avaliable)
						}
					}
				}
				else
				{
					for (var i in 0..dst.count) {
						if (dst[i].size < 0) {
							var len = -dst[i].size
							dst[i].size = Math.min(len, avaliable * len / tot_floating)
						}
					}
				}
			}
			else
			{
				for (var i in 0..dst.count) {
					if (dst[i].size < 0) {
						dst[i].size = 0
					}
				}
			}
		}

		// trim sizes
		if (!dst.isEmpty)
		{
			var len = 0
			var idx = 0
			while (idx < dst.count and len + dst[idx].size < length) {
				len = len + dst[idx].size
				idx = idx + 1
			}

			if (idx < dst.count)
			{
				dst[idx].size = length - len
				for (var i in idx + 1 .. dst.count) {
					dst[i].size = 0
				}
			}
		}

		// calc tot len
		var len = 0
		for (var sz in dst) {
			len = len + sz.size
		}

		return len
	}

	dynamic_exports_update()
	{
		var num = 0
		for (var i in 1 .. this.imports.count) {
			if (!this.imports[i].conns.isEmpty) {
				num = num + 1
			}
		}
		while (this.exports.count > num) {
			this.exports.pop_back()
		}
		while (this.exports.count < num) {
			this.exports.add(Pin(this, "child%(this.exports.count)", VAR_TYPE_GEOMETRY))
		}

		this.layout()

		for (var port in this.exports) {
			for (var conn in port.conns) {
				conn.update()
			}
		}
	}

	create_geo(rect)
	{
		var xmin = rect.x
		var xmax = rect.x + rect.w
		var zmin = rect.y
		var zmax = rect.y + rect.h
		var y = 0

		var points = []
		points.add(PolyPoint.init([ xmin, y, zmin ]))
		points.add(PolyPoint.init([ xmin, y, zmax ]))
		points.add(PolyPoint.init([ xmax, y, zmax ]))
		points.add(PolyPoint.init([ xmax, y, zmin ]))

		var face = PolyFace.init([ 0, 1, 2, 3 ], [])
		var poly = Polytope.init(points, [ face ])

	    var geo = Geometry([ poly ])
		return Variant(VAR_TYPE_GEOMETRY, geo)
	}

	create_geo(rect, face, points, ori_p, dir_x, dir_y, parent_scope)
	{
		var x_min = rect.x
		var x_max = x_min + rect.w
		var y_min = rect.y
		var y_max = y_min + rect.h

		var axis = this.query_param("axis").value
		if (axis == "hori") {
			var h_dx = rect.w * (rect.s - 1.0) / 2
			x_min = x_min - h_dx
			x_max = x_max + h_dx
		} else {
			var h_dy = rect.h * (rect.s - 1.0) / 2
			y_min = y_min - h_dy
			y_max = y_max + h_dy		
		}

		var pts = []
		pts.add(PolyPoint.init(this.coordinate_mapping(x_min, y_max, ori_p, dir_x, dir_y)))		
		pts.add(PolyPoint.init(this.coordinate_mapping(x_min, y_min, ori_p, dir_x, dir_y)))
		pts.add(PolyPoint.init(this.coordinate_mapping(x_max, y_min, ori_p, dir_x, dir_y)))
		pts.add(PolyPoint.init(this.coordinate_mapping(x_max, y_max, ori_p, dir_x, dir_y)))		

		var f = PolyFace.init([ 0, 1, 2, 3 ], [])
		var poly = Polytope.init(pts, [ f ])

	    var geo = Geometry([ poly ])
	    geo.scope = ScopeHelper.calc_mat(poly, f, axis == "hori", parent_scope)
		return Variant(VAR_TYPE_GEOMETRY, geo)
	}

	coordinate_mapping(x, y, ori_p, dir_x, dir_y)
	{
		var v3 = ori_p.add(dir_x.mul(x)).add(dir_y.mul(y))
		return [ v3.x, v3.y, v3.z ]
	}	
}